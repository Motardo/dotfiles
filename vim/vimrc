set nocompatible
filetype indent plugin on
syntax on

call plug#begin()
Plug 'arrufat/vala.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'eagletmt/ghcmod-vim'
Plug 'eagletmt/neco-ghc'
Plug 'elmcast/elm-vim'
Plug 'ervandew/supertab'
Plug 'flazz/vim-colorschemes'
Plug 'garbas/vim-snipmate'
Plug 'godlygeek/tabular'
Plug 'jiangmiao/auto-pairs'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'majutsushi/tagbar'
Plug 'raichoo/purescript-vim'
Plug 'scrooloose/nerdcommenter'
Plug 'scrooloose/syntastic'
Plug 'Shougo/neocomplete.vim'
Plug 'Shougo/vimproc.vim', {'do' : 'make'}
Plug 'tomtom/tlib_vim'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-surround'
call plug#end()"

set path+=**
set wildmenu
set showcmd " Show partial commands in the last line of the screen
set hlsearch
set nomodeline

" put git status, column/row number, total lines, and percentage in status
set statusline=%F%m%r%h%w\ %{fugitive#statusline()}\ [%l,%c]\ [%L,%p%%]
" highlight the status bar when in insert mode
if version >= 700
  au InsertEnter * hi StatusLine ctermfg=235 ctermbg=2
  au InsertLeave * hi StatusLine ctermbg=239 ctermfg=15
endif
set ignorecase
set smartcase
set nostartofline
set confirm
set visualbell
set cmdheight=2
set number
set notimeout

set t_Co=256
colorscheme xoria256
set cursorline

set shiftwidth=2
set expandtab
set tabstop=8

"------------------------------------------------------------
" Mappings

nnoremap , :
vnoremap , :

nnoremap : ,
vnoremap : ,

nnoremap % \
vnoremap % \

nnoremap Y y$

nnoremap zl $
nnoremap zh ^

" Quickfix list navigation
nnoremap zc :cclose<cr>:lclose<cr>
nnoremap zo :copen<cr>:lop<cr>
nnoremap zd :cn<cr>
nnoremap zu :cp<cr>

" Location list navigation
"nnoremap zc :lcl<cr>
"nnoremap zo :lop<cr>
nnoremap zn :lne<cr>
nnoremap zp :lpr<cr>

vnoremap . :norm.<cr>

" Insert mode mappings
"------------------------------------------------------------

noremap! jk <esc>
noremap! <C-F> <Esc>gUiw`]a
inoremap <C-L> <Esc>%%a

" Leader key mappings
"------------------------------------------------------------

let mapleader=" "
"let maplocalleader=" "

nnoremap <leader>P "+P
nnoremap <leader>e :Errors<CR>
nnoremap <leader>f :buffers<CR>:buffer<space>
nnoremap <leader>j ddp
nnoremap <leader>k kddpk
nnoremap <leader>l :set nolist!<cr>
nnoremap <leader>n :set norelativenumber!<cr>
nnoremap <leader>p o<esc>"+p
nnoremap <leader>q :q<cr>
nnoremap <leader>s :write<cr>
nnoremap <leader>ve :e $MYVIMRC<cr>
nnoremap <leader>vs :source $MYVIMRC<cr>

let g:netrw_liststyle=3
let g:netrw_banner=0
let g:netrw_altv=1
let g:netrw_preview=1
autocmd FileType netrw setl bufhidden=delete

let g:elm_syntastic_show_warnings = 1"
let g:syntastic_ruby_checkers = ['mri', 'rubocop']
let g:syntastic_javascript_checkers = ['jshint', 'jscs']
let g:syntastic_haskell_checkers = ['hlint', 'hdevtools']
let g:syntastic_html_tidy_ignore_errors = ['unescaped &', 'lacks "action']
"------------------------------------------------------------

set wildignore+=node_modules
set wildignore+=public/lib

highlight Normal ctermbg=None

let g:elm_format_autosave = 1

" Extended Text Objects
let s:items = [ "<bar>", "\\", "/", ":", ".", "*", "_" ]
for item in s:items
    exe "nnoremap yi".item." T".item."yt".item
    exe "nnoremap ya".item." F".item."yf".item
    exe "nnoremap ci".item." T".item."ct".item
    exe "nnoremap ca".item." F".item."cf".item
    exe "nnoremap di".item." T".item."dt".item
    exe "nnoremap da".item." F".item."df".item
    exe "nnoremap vi".item." T".item."vt".item
    exe "nnoremap va".item." F".item."vf".item
endfor

" == syntastic ==

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0

" == ghc-mod ==

map <silent> tw :GhcModTypeInsert<CR>
map <silent> ts :GhcModSplitFunCase<CR>
map <silent> tq :GhcModType<CR>
map <silent> te :GhcModTypeClear<CR>

" == supertab ==

let g:SuperTabDefaultCompletionType = "context"

" == necomplete ==

" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#sources#syntax#min_keyword_length = 2
let g:neocomplete#enable_auto_delimiter = 1

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-k>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" == neco-ghc ==

" Disable haskell-vim omnifunc
let g:haskellmode_completion_ghc = 0
autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

let g:necoghc_enable_detailed_browse = 1

" == tabular ==

let g:haskell_tabular = 1

vmap a= :Tabularize /=<CR>
vmap a; :Tabularize /::<CR>
vmap a- :Tabularize /-><CR>
vmap a, :Tabularize /<-<CR>
vmap al :Tabularize /[\[\\|,]<CR>

" == ctrl-p ==

"map <silent> <Leader>t :CtrlP()<CR>
noremap <leader>b<space> :CtrlPBuffer<cr>
let g:ctrlp_custom_ignore = '\v[\/]dist$'

let g:tagbar_ctags_bin = "anjuta-tags"
